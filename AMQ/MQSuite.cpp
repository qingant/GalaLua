#include "MQSuite.hpp"
#include "MQBuilder.hpp"
#include "MQException.hpp"


const BYTE BKD_INFOQRY[]={0xFF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0x82,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0x82,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0x8A,0xDA,0xD0,0x8A,0xDA,0xD0,0x8A,0xDA,0xC2,0x8B,0x96,0x92,0x96,0xB3,0x9A,0x8B,0x9E,0xBB,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0x8C,0xDA,0xC2,0x8D,0x9A,0x8C,0xAA,0x9B,0x91,0xBA,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0x8C,0xDA,0xC2,0x8D,0x9A,0x91,0x8B,0x8D,0x9E,0xAF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0x8C,0xDA,0xC2,0x8D,0x9A,0x9B,0x96,0x89,0x90,0x8D,0xAF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0x84,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0xC5,0xBC,0xB6,0xB3,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0xF5,0x82,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0x8A,0xDA,0xC2,0x8C,0xAE,0xBB,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0x8A,0xDA,0xC2,0x8C,0xAE,0xB1,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0x8A,0xDA,0xC2,0x9A,0x85,0x96,0xAC,0x9A,0x98,0x9E,0xAF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0x8A,0xDA,0xC2,0x8C,0x9A,0x98,0x9E,0xAF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0x84,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0xC5,0xAE,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0xF5,0x8F,0x93,0xDA,0xC2,0x92,0x8A,0xAC,0x94,0x9C,0x9A,0x97,0xBC,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0x8C,0xDA,0xC2,0x9A,0x8B,0x9E,0xBB,0x9A,0x8B,0x9E,0x9A,0x8D,0xBC,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0x8B,0x96,0x9D,0xD2,0x8A,0xDA,0xC2,0x9A,0x9B,0x96,0xA8,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0x8A,0xDA,0xD1,0x8A,0xDA,0xC5,0x91,0x90,0x96,0x8C,0x8D,0x9A,0xA9,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0x8C,0xDA,0xC5,0x8D,0x90,0x97,0x8B,0x8A,0xBE,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0xAE,0xB2,0x86,0x87,0x9E,0x93,0x9E,0xB8,0xC5,0x9A,0x92,0x9E,0xB1,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0x84,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xF5,0};
const BYTE MQ_PROVIDER[]={0xFF,0x98,0x8D,0x90,0xD1,0xAF,0xAF,0xBC,0xD1,0x86,0x87,0x9E,0x93,0x9E,0xB8,0xD1,0x89,0x9A,0x9B,0x00};
const BYTE MQ_CONSUMER[]={0xFF,0x91,0x9C,0xD1,0x92,0x90,0x9C,0xD1,0x9A,0x9A,0x8D,0x98,0x9E,0xD1,0x88,0x88,0x88,0};
const BYTE CC_ENV[] = {0xFF,0x91,0x90,0x96,0x8B,0x9E,0x92,0x8D,0x90,0x99,0x91,0xB6,0xAE,0xB2,0x86,0x87,0x9E,0x93,0x9E,0xB8,0x86,0x8D,0x9A,0x8A,0xAE,0};

namespace Galaxy
{
	namespace AMQ
	{
		class CMQCopyrightChecker
		{
		public:
			CMQCopyrightChecker(const CMQSuite &_MQSuite);
			~CMQCopyrightChecker();
		};
	}
}

using namespace Galaxy::AMQ;

inline PBYTE __XCHG_BYTE_ARRAY__(CPBYTE _BArray,UINT _Length,PBYTE _NewArray,UINT _Size)
{
	for(UINT i=0;(_Size > _Length) && (i<_Length) && (i< _Size);i++)
	{
		_NewArray[(_Length-1)-i] = ((~_BArray[i]) & 0xFF);	
	}
	
	_NewArray[_Length]=0;
	
	return _NewArray;	
}

/*CMQSuite*/
CMQSuite::CMQSuite(const std::string &_FileName)
   :_Anchor(CreateAnchor(_FileName)), 
    _Pooler(*_Anchor),_NQArray(_Pooler),_DQArray(_Pooler),
    _PoolerView(*(_Anchor->GetPoolerQueueEntry()),*(_Anchor->GetNodesEntry()))
{
	CMQCopyrightChecker	_Checker(*this);    
}

CMQSuite::CMQSuite(key_t _IPCKey)
   :_Anchor(CreateAnchor(_IPCKey)), 
    _Pooler(*_Anchor),_NQArray(_Pooler),_DQArray(_Pooler),
    _PoolerView(*(_Anchor->GetPoolerQueueEntry()),*(_Anchor->GetNodesEntry()))
{
	CMQCopyrightChecker	_Checker(*this);	
}

CMQSuite::~CMQSuite()
{
	if(_Anchor!=NULL)
	{
		delete _Anchor;
		_Anchor = NULL;	
	}    
}

CAnchor *CMQSuite::CreateAnchor(const std::string &_FileName)
{
	CAnchor	*_TheAnchor = new CFileMemoryAnchor(_FileName,false,0);
	if(ISNULL(_TheAnchor))
	{
		THROW_MQEXCEPTION("new CFileMemoryAnchor Failure!"); 	
	}
	
	return _TheAnchor;
}

CAnchor *CMQSuite::CreateAnchor(key_t _IPCKey)
{
	CAnchor	*_TheAnchor = new CSHMAnchor(_IPCKey,false,0);
	if(ISNULL(_TheAnchor))
	{
		THROW_MQEXCEPTION("new CSHMAnchor Failure!"); 	
	}
	return _TheAnchor;
}

const IMQueueArray &CMQSuite::NQArray() const
{
   return _NQArray;    
}

const IMQueueArray &CMQSuite::DQArray() const
{
   return _DQArray;    
}

const IPoolerView &CMQSuite::PoolerView() const
{
    return _PoolerView;   
}


#define MQ_BKDINFO			(0xFF424B44)	//信息控制码
#define MQ_BKDUPDLIC		(0x01)			//信息控制码

//这个用于查询许可证信息或其它权属性息
void CMQSuite::BKD(UINT _BKDCode,...) const
{
	if(MQ_BKDINFO == _BKDCode)
	{
		CHAR	szInfo[8192];
		BYTE	szAuthor[9];
		BYTE	szFmt[sizeof(BKD_INFOQRY)];	
		
		
		CPSQINFO _CInfo = _Anchor->GetInfoEntry();
		
		PBYTE _PtrAuthor = (PBYTE)&(_CInfo->_Author);
      	
      	szAuthor[0] = (~_PtrAuthor[7]) & 0xFF;
      	szAuthor[1] = (~_PtrAuthor[6]) & 0xFF;
      	szAuthor[2] = (~_PtrAuthor[5]) & 0xFF;
   		szAuthor[3] = (~_PtrAuthor[4]) & 0xFF;
      	szAuthor[4] = (~_PtrAuthor[3]) & 0xFF;
   		szAuthor[5] = (~_PtrAuthor[2]) & 0xFF;
      	szAuthor[6] = (~_PtrAuthor[1]) & 0xFF;
      	szAuthor[7] = (~_PtrAuthor[0]) & 0xFF;
      	szAuthor[8] = 0;
      	
		BYTE            szStamp[64];
		{
			struct	tm 		_tme;

			CRT_localtime_r(&(_CInfo->_CreateDate), &_tme);
			
			CRT_snprintf((PSTR) szStamp,sizeof(szStamp), "%04d/%02d/%02d %02d:%02d:%02d", \
			        _tme.tm_year+1900,_tme.tm_mon+1,_tme.tm_mday,_tme.tm_hour,_tme.tm_min, \
			        _tme.tm_sec );
		}
		
		CMQLicense _License(_CInfo->_License);
		
		CRT_snprintf(szInfo,sizeof(szInfo),  \
			(PSTR)__XCHG_BYTE_ARRAY__(BKD_INFOQRY,sizeof(BKD_INFOQRY)-1,szFmt,sizeof(szFmt)), \
			(PSTR)szAuthor, \
			((_CInfo->_Magic[3] & 0xF0) >> 4),\
			(_CInfo->_Magic[3] & 0x0F), \
			(_CInfo->_Magic[1] * 8), \
			(PSTR)szStamp, \
			_CInfo->_CheckSum, \
			_Pooler.Nodes().Pages(), \
			_Pooler.Nodes().PageSize(), \
			_NQArray.Count() ,\
			_DQArray.Count(),
			_License.Provider(),
			_License.Consumer(),
			_License.Licensed(),
			(_License.DateLimit() >> 16) & 0xFFFF,
			(_License.DateLimit() >> 8) & 0xFF,
			(_License.DateLimit() & 0xFF)
			);
		
		THROW_MQEXCEPTION(szInfo); 
	} 	
}


/*CMQCopyrightChecker*/
CMQCopyrightChecker::CMQCopyrightChecker(const CMQSuite &_MQSuite)
{
	/*getenv("QueryGalaxyMQInformation")*/	
	BYTE	szEnv[64];
	__XCHG_BYTE_ARRAY__(CC_ENV,sizeof(CC_ENV)-1,szEnv,sizeof(szEnv));
	
	CPSTR _IsQuery = CRT_getenv((PSTR)szEnv);
	if((_IsQuery!=NULL) && ((_IsQuery[0]=='Y')||(_IsQuery[0]=='y')||(_IsQuery[0]=='1')))
	{
		_MQSuite.BKD(MQ_BKDINFO,NULL);	
	}
}

CMQCopyrightChecker::~CMQCopyrightChecker()
{
	
}


/*CMQCreator*/
CMQCreator::CMQCreator(const std::string &_FileName,const std::string &_EndUser,UINT _Pages,
                        UINT _PageSize,UINT _NQs,UINT _DQs,UINT _DefaultDepthPeerQ,
                        UINT _Year,UINT _Month,UINT _Day)
{
	{
		BYTE	szP[64];
		BYTE	szC[64];
		
		{
			__XCHG_BYTE_ARRAY__(MQ_PROVIDER,sizeof(MQ_PROVIDER)-1,szP,sizeof(szP));
			
			
			__XCHG_BYTE_ARRAY__(MQ_CONSUMER,sizeof(MQ_CONSUMER)-1,szC,sizeof(szC));
		}
		
		CMQLicenseBuilder _LicBuilder((PBYTE)szP,(PBYTE)szC,(PBYTE)_EndUser.c_str(),_Pages,_PageSize,_NQs,_DQs,_Year,_Month & 0xFF,_Day & 0xFF);
		CMQLicense  _License(_LicBuilder.GetLicense());
		
		CFileMemoryAnchor _Anchor(_FileName,true,::MQEvaluate(_License.MaxPages(),_License.MaxPageSize(),_License.MaxNQs(),_License.MaxDQs()));
		CMQBuilder  _Builder(_Anchor,_License,_DefaultDepthPeerQ);
	}
}

CMQCreator::CMQCreator(key_t _IPCKey,const std::string &_EndUser,UINT _Pages,
                        UINT _PageSize,UINT _NQs,UINT _DQs,UINT _DefaultDepthPeerQ,
                        UINT _Year,UINT _Month,UINT _Day)
{
	{
		BYTE	szP[64];
		BYTE	szC[64];
		
		{
			__XCHG_BYTE_ARRAY__(MQ_PROVIDER,sizeof(MQ_PROVIDER)-1,szP,sizeof(szP));
			
			
			__XCHG_BYTE_ARRAY__(MQ_CONSUMER,sizeof(MQ_CONSUMER)-1,szC,sizeof(szC));
		}
		
		CMQLicenseBuilder _LicBuilder(szP,szC,(PBYTE)_EndUser.c_str(),_Pages,_PageSize,_NQs,_DQs,_Year,_Month & 0xFF,_Day & 0xFF);
		CMQLicense  _License(_LicBuilder.GetLicense());
		
		CSHMAnchor _Anchor(_IPCKey,true,::MQEvaluate(_License.MaxPages(),_License.MaxPageSize(),_License.MaxNQs(),_License.MaxDQs()));
		CMQBuilder  _Builder(_Anchor,_License,_DefaultDepthPeerQ);
	}
}

CMQCreator::~CMQCreator()
{
    
}
